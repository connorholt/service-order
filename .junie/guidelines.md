# Project Guidelines — STR Quality Style Guide

This document defines code style, architectural conventions, and development workflow for Go services following the STR Quality project style. Junie will use these rules to produce code with similar structure and style across projects.

## 1. Architecture & Project Layout
- Adopt Clean Architecture layering:
    - domain/ (entity, value objects, pure business rules) — no external deps.
    - usecase/ (application services, orchestration) — depends on domain and internal contracts only.
    - repository/ (DB adapters) — implements usecase contracts.
    - gateway/ (external service clients) — implements usecase contracts and maps to external DTOs.
    - model/ (transport/integration DTOs) — used by adapters/gateways, not by usecases directly.
    - util/ (small pure utilities) — generic helpers with no external deps.
    - cmd/ (entrypoints) — wire dependencies and configs.
- Dependency rule: usecase must not import gateway/repository/model. Use interfaces in usecase/contract.go and map external DTOs in adapters.
- Configuration/time: inject config and a Clock interface into usecases, avoid direct time.Now in business logic. Where legacy uses time.Now, plan refactoring.
- Metrics/logging: expose side-effect interfaces in usecases (metric, log). Avoid leaking context-mutation semantics into domain logic.

## 2. Packages & Files
- One usecase per directory: internal/usecase/<bounded-context>/<action>/
    - contract.go — interfaces for repos/gateways/log/metric; include go:generate for mocks.
    - <usecase>.go — orchestrating logic with New(...) constructor and methods.
    - <usecase>_test.go — table-driven tests with gomock and testify/assert.
    - mocks_test.go — generated by mockgen into the same folder, package <pkg>_test.
- Domain entities: internal/domain/entity/*.go
    - Pure structs, constants, methods with business rules, no external packages.
- Utilities: internal/util/<topic>/*.go — pure functions (e.g., series.Create).
- Models (integration DTOs): internal/model/*.go — constants and request/response structs.

## 3. Naming & Formatting
- Go 1.21+ standard formatting: go fmt ./...; keep imports grouped (std, third-party, internal).
- Constructors: New..., e.g., New(q Repo, g Gateway, l Log, m Metric) *Usecase
- Interfaces: thin, named by role: sellerQualityRepo, punishmentGateway, log, metric.
- Constants: UPPER_CAMEL or snake for external keys depending on usage. Metric keys and config keys are string constants near usecase until centralized.
- Errors: wrap with context using fmt.Errorf("context: %w", err). Use sentinel errors in domain as needed. No logging at repository/gateway except when necessary for IO; return errors to usecase.

## 4. Context & Concurrency
- All public usecase methods accept context.Context as the first param.
- Avoid storing context in structs; thread it through method calls.
- For concurrency: avoid goroutine leaks, prefer errgroup with context. Respect context cancellation in external calls.

## 5. Logging
- Use structured logging via a minimal interface in usecase:
    - type log interface { WithFields(ctx context.Context, fields map[string]any) context.Context; Info(ctx context.Context, args ...any) }
- Do not mutate domain state for logging. Keep log usage minimal in usecases (info/warn for important decisions). Enrich fields with domain identifiers (seller_id, booking_id).

## 6. Metrics
- Use a minimal metric interface in usecase: type metric interface { Increment(key string) }
- Metric keys are constants at top of the usecase file. Consider centralization when keys become shared across usecases.
- Emit metrics on decision branches (candidate, exists, success, failure if appropriate), matching current style.

## 7. Configuration
- Use internal/configure for loading env/config files. Inject specific config structs into constructors.
- Avoid hardcoded constants for business parameters (limits, periods). Expose UsecaseConfig and Clock where feasible:
    - type Clock interface { Now() time.Time }
    - Prefer u.clock.Now() over time.Now().

## 8. Gateways & DTO Mapping
- Usecases operate with domain primitives (IDs, enums, value objects).
- Gateways are responsible for mapping domain calls to external DTOs in internal/model (e.g., model.BlockUserRequest).
- Keep gateway contracts small and focused; transport/SDK types must not leak into usecases.

## 9. Repositories
- Define repository interfaces in usecase/contract.go with domain-centric signatures.
- Avoid storage-specific leakage (raw table columns). Use domain entities or small value objects (e.g., []int64 is acceptable for event IDs if it’s a meaningful domain concept).

## 10. Testing Style
- Use standard testing + testify/assert and gomock.
- Table-driven tests with t.Run and t.Parallel within each table case when safe.
- Pattern:
    - Arrange: create gomock.Controller; create mocks with NewMock...; build usecase via New(...).
    - Act: call usecase method.
    - Assert: assert.NoError/Error and validate side effects via mock expectations.
- Generate mocks next to the usecase using go:generate in contract.go:
    - //go:generate mockgen -source ${GOFILE} -destination mocks_test.go -package ${GOPACKAGE}_test
    - Regenerate: go generate ./...
- Keep test package separate (package <pkg>_test) to emulate external usage and enforce public API testing.
- Use descriptive, behavior-oriented test names and inline comments for tags, e.g.:
    - // tagID 19634 <short description>
    - // tmsTestType unit

## 11. Error Messages & Wrapping
- Error messages from usecases should include the layer and action for traceability, e.g.:
    - "block usecase: failed to check if seller is blocked: %w"
- Repositories/gateways add context about the specific operation, but avoid redundant nesting.

## 12. Performance & Allocations
- Prefer preallocation when feasible (e.g., toEventIDs with capacity).
- Keep utilities pure and allocation-aware (see util/series).
- Use pointers only when needed (mutability, nil semantics, avoiding large copies).

## 13. CI, Linting, and Commands
- Formatting: go fmt ./...
- Vet: go vet ./...
- Lint: golangci-lint run (if present); otherwise rely on vet + staticcheck as available.
- Tests: go test -race -count=1 ./...
- Codegen: go generate ./... (ensure mockgen installed: go install github.com/golang/mock/mockgen@latest)

## 14. Commit & PR Conventions
- Branches: feature/<task-id>-short-title
- Conventional Commits: feat:, fix:, refactor:, test:, chore:
- PR checklist: lints pass; tests added/updated; migrations (if any); backward compatibility; performance implications; docs updated.

## 15. Example Usecase Skeleton
- Directory: internal/usecase/foo/bar/
    - contract.go
        - //go:generate mockgen -source ${GOFILE} -destination mocks_test.go -package ${GOPACKAGE}_test
        - Define interfaces: fooRepo, externalGateway, log, metric
    - bar.go
        - type Usecase struct { ... }
        - func New(...) *Usecase { ... }
        - func (u *Usecase) Execute(ctx context.Context, input ...) error { ... }
    - bar_test.go
        - Table-driven tests with gomock and testify

## 16. Documentation Expectations
- Each usecase should have a short doc-comment explaining the business rule it enforces and key decision points.
- Domain entity files should document constants/enums (statuses, types, sources) and behavior methods.

## 17. When Adding New Features
- Start with domain definitions (entities, constants).
- Define usecase contract interfaces.
- Implement usecase logic (pure orchestration, inject deps via constructor).
- Implement adapters (repository/gateway) that satisfy contracts; put DTO mapping in adapters.
- Add unit tests for usecase; integration tests for adapters as required.

## 18. How Junie Should Work With This Project Style
- Prefer producing unified diffs; place new usecases under internal/usecase/<area>/<action>/.
- Always include mocks via go:generate in contract.go; provide mockgen command.
- Write table-driven tests mirroring the patterns in internal/usecase/order/save and internal/usecase/seller/block.
- Avoid introducing external DTOs into usecase layer; keep configs and time injectable.

This style guide should be used as the baseline for new services to ensure consistency with the STR Quality project’s code style and architecture. If a project requires deviations, document them near the affected usecase or adapter.
